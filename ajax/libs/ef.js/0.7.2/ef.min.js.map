{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/subscriber-call-stack.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/ef-core.js","../src/ef.js","../src/lib/parser.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = '__EFPLACEHOLDER__ $parent $key $data $element $refs $methods $mount $umount $subscribe $unsubscribe $update $destroy __DIRECTMOUNT__'.split(' ')\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = new RegExp(`^${parsingInfo.offset}`)\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif (/^\\s/.test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeProps = (string) => {\n\tconst splited = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splited.shift().trim()),\n\t\tvalue: splitLiterals(splited.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splited = splitBy(string, '=')\n\treturn {\n\t\tname: splited.shift().trim(),\n\t\tvalue: splited.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetIndent(line, parsingInfo)\n\tgetOffset(line, parsingInfo)\n\n\tlet { depth, content } = getDepth(removeOffset(line, parsingInfo, i), parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!parsingInfo.topExists && typeSymbols.indexOf(type) >= 0 && type !== '>') throw new SyntaxError(getErrorMsg('No top level entry', i))\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tif (!parsingInfo.topExists) {\n\t\t\t\t\tparsingInfo.topExists = true\n\t\t\t\t\tparsingInfo.minDepth = depth\n\t\t\t\t}\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { name, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = {}\n\t\t\t\tparsingInfo.currentNode[0].p[name] = value\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = []\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast[0]) return ast[0]\n\tthrow new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) string += (strs[i] + exprs[i])\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => dataNode[_key]\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport { mixStr, mixVal }\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (window.Set && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\nconst isPaused = () => count > 0\n\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tfor (let i of renderQueue) i()\n\tif (process.env.NODE_ENV !== 'production') console.info('[EF]', `${modificationQueue.length} modification operation(s) cached, ${renderQueue.length} executed.`)\n\tARR.empty(modificationQueue)\n}\n\nconst execDomModifications = () => {\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tfor (let i of domRenderQueue) i()\n\tif (process.env.NODE_ENV !== 'production') console.info('[EF]', `${domQueue.length} DOM operation(s) cached, ${domRenderQueue.length} executed.`)\n\tARR.empty(domQueue)\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tfor (let i of userFnQueue) i()\n\tif (process.env.NODE_ENV !== 'production') console.info('[EF]', `${userQueue.length} user operation(s) cached, ${userFnQueue.length} executed.`)\n\tARR.empty(userQueue)\n}\n\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\treturn exec(cb(inform, exec))\n\t} catch (e) {\n\t\tconsole.error('[EF]', 'Error caught when executing bundle:\\n', e)\n\t\treturn exec()\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst _assign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || _assign\n\nexport { assign }\n","import { inform, exec } from './render-queue.js'\nimport { assign } from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\nconst resolveReactivePath = (_path, obj, enume) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) {\n\t\t\tconst node = {}\n\t\t\tObject.defineProperty(obj, i, {\n\t\t\t\tget() {\n\t\t\t\t\treturn node\n\t\t\t\t},\n\t\t\t\tset(data) {\n\t\t\t\t\tinform()\n\t\t\t\t\tassign(node, data)\n\t\t\t\t\texec()\n\t\t\t\t},\n\t\t\t\tconfigurable: !enume,\n\t\t\t\tenumerable: enume\n\t\t\t})\n\t\t}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({ _path, _key, data, handlers, subscribers, innerData }) => {\n\tconst parentNode = resolveReactivePath(_path, data, true)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = ''\n\treturn { parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode }\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport { resolveReactivePath, resolve, resolveSubscriber }\n","import { inform, exec } from './render-queue.js'\nimport ARR from './utils/array-helper.js'\n\nconst subscriberCallStack = []\n\nconst checkStack = subscriberNode => subscriberCallStack.indexOf(subscriberNode) >= 0\n\nconst pushStack = subscriberNode => subscriberCallStack.push(subscriberNode)\n\nconst popStack = subscriberNode => ARR.remove(subscriberCallStack, subscriberNode)\n\nconst execSubscribers = (subscriberNode, data) => {\n\t// Stop chain reaction when being called again in the context\n\t// There is no way for the caller to know it shouldn't update the node again\n\t// So this is the only method to avoid recursion\n\t// Push the current subscriberNode to stack as an identifier\n\tpushStack(subscriberNode)\n\t// Execute the subscriber function\n\tinform()\n\ttry {\n\t\tfor (const subscriber of subscriberNode) subscriber(data)\n\t} catch (e) {\n\t\tconsole.error('[EF]', 'Error caught when executing subscribers:\\n', e)\n\t}\n\texec()\n\t// Remove the subscriberNode from the stack so it could be called again\n\tpopStack(subscriberNode)\n}\n\nexport { subscriberCallStack, checkStack, pushStack, popStack, execSubscribers }\n","/* eslint {\"no-self-compare\": \"off\"} */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","import { resolve } from './resolver.js'\nimport { inform, exec, queue } from './render-queue.js'\nimport { execSubscribers } from './subscriber-call-stack.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, state, _key}) => {\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) execSubscribers(subscriberNode, {state, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, state, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst { parentNode, handlerNode, subscriberNode, dataNode } = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: state.$data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, state, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, props = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = document.createEvent('Event')\n\tevent.initEvent(name, props.bubbles, props.cancelable)\n\treturn event\n}\n\nexport default getEvent\n","import initBinding from './binding.js'\nimport { queue, inform, exec } from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport { mixVal } from './utils/literals-mix.js'\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// SVG tags require namespace to work properly\nconst createByTag = (tag, svg) => {\n\tif (svg) return document.createElementNS('http://www.w3.org/2000/svg', tag)\n\treturn document.createElement(tag)\n}\n\nconst getElement = ({tag, ref, refs, svg}) => {\n\tconst element = createByTag(tag, svg)\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, state, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, state, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst updateOthers = ({parentNode, handlerNode, _handler, _key, value}) => {\n\t// Remove handler for this element temporarily\n\tARR.remove(handlerNode, _handler)\n\tinform()\n\tparentNode[_key] = value\n\texec()\n\t// Add back the handler\n\tARR.push(handlerNode, _handler)\n}\n\nconst addValListener = ({_handler, state, handlers, subscribers, innerData, element, key, expr}) => {\n\tconst {parentNode, handlerNode, _key} = initBinding({bind: expr, state, handlers, subscribers, innerData})\n\tconst _update = () => updateOthers({parentNode, handlerNode, _handler, _key, value: element.value})\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement.addEventListener('input', _update, true)\n\t\telement.addEventListener('keyup', _update, true)\n\t\telement.addEventListener('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element.addEventListener('input', removeListener, true)\n\t} else {\n\t\telement.addEventListener('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement.dispatchEvent(getEvent('ef-change-event'))\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = document.querySelectorAll(`input[name=${element.name}]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement.addEventListener('ef-change-event', () => updateOthers({parentNode, handlerNode, _handler, _key, value: element.checked}))\n\t}\n}\n\nconst getAttrHandler = (element, key) => {\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, state, handlers, subscribers, innerData}) => {\n\tif (checkValidType(attr)) element.setAttribute(key, attr)\n\telse {\n\t\tconst handler = getAttrHandler(element, key)\n\t\tqueue([regTmpl({val: attr, state, handlers, subscribers, innerData, handler})])\n\t}\n}\n\nconst addProp = ({element, prop, key, state, handlers, subscribers, innerData}) => {\n\tif (checkValidType(prop)) element[key] = prop\n\telse {\n\t\tconst handler = (val) => {\n\t\t\telement[key] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: prop, state, handlers, subscribers, innerData, handler})\n\t\tif ((key === 'value' ||\n\t\t\tkey === 'checked') &&\n\t\t\t!prop[0]) addValListener({_handler, state, handlers, subscribers, innerData, element, key, expr: prop[1]})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, state, handlers, subscribers, innerData}) => {\n\n\t/**\n\t *  l: listener\t\t\t\t\t\t\t\t\t: string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, state, handlers, subscribers, innerData, handler: rawHandler})\n\telement.addEventListener(l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (state.$methods[m]) state.$methods[m]({e, value: _handler(), state})\n\t\telse if (process.env.NODE_ENV !== 'production') console.warn('[EF]', `Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, state, innerData, refs, handlers, subscribers, svg}) => {\n\n\t/**\n\t *  t: tag       : string\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst element = getElement({tag: t, ref: r, refs, svg})\n\tfor (let i in a) addAttr({element, attr: a[i], key: i, state, handlers, subscribers, innerData})\n\tfor (let i in p) addProp({element, prop: p[i], key: i, state, handlers, subscribers, innerData})\n\tfor (let i in e) addEvent({element, event: e[i], state, handlers, subscribers, innerData})\n\treturn element\n}\n\nexport default createElement\n","const proto = Node.prototype\n// const safeZone = document.createDocumentFragment()\n\nconst DOM = {\n\t// addClass(node, className) {\n\t// \tconst classes = className.split(' ')\n\t// \tnode.classList.add(...classes)\n\t// },\n\n\t// removeClass(node, className) {\n\t// \tconst classes = className.split(' ')\n\t// \tnode.classList.remove(...classes)\n\t// },\n\n\t// toggleClass(node, className) {\n\t// \tconst classes = className.split(' ')\n\t// \tconst classArr = node.className.split(' ')\n\t// \tfor (let i of classes) {\n\t// \t\tconst classIndex = classArr.indexOf(i)\n\t// \t\tif (classIndex > -1) {\n\t// \t\t\tclassArr.splice(classIndex, 1)\n\t// \t\t} else {\n\t// \t\t\tclassArr.push(i)\n\t// \t\t}\n\t// \t}\n\t// \tnode.className = classArr.join(' ').trim()\n\t// },\n\n\t// replaceWith(node, newNode) {\n\t// \tconst parent = node.parentNode\n\t// \tif (parent) proto.replaceChild.call(parent, newNode, node)\n\t// },\n\n\t// swap(node, newNode) {\n\t// \tconst nodeParent = node.parentNode\n\t// \tconst newNodeParent = newNode.parentNode\n\t// \tconst nodeSibling = node.nextSibling\n\t// \tconst newNodeSibling = newNode.nextSibling\n\t// \tif (nodeParent && newNodeParent) {\n\t// \t\tproto.insertBefore.call(nodeParent, newNode, nodeSibling)\n\t// \t\tproto.insertBefore.call(newNodeParent, node, newNodeSibling)\n\t// \t}\n\t// },\n\n\tbefore(node, ...nodes) {\n\t\tconst tempFragment = document.createDocumentFragment()\n\t\tnodes.reverse()\n\t\tfor (let i of nodes) proto.appendChild.call(tempFragment, i)\n\t\tproto.insertBefore.call(node.parentNode, tempFragment, node)\n\t},\n\n\tafter(node, ...nodes) {\n\t\tconst tempFragment = document.createDocumentFragment()\n\t\tfor (let i of nodes) proto.appendChild.call(tempFragment, i)\n\t\tif (node.nextSibling) proto.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\t\telse proto.appendChild.call(node.parentNode, tempFragment)\n\t},\n\n\tappend(node, ...nodes) {\n\t\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\t\tconst tempFragment = document.createDocumentFragment()\n\t\tfor (let i of nodes) proto.appendChild.call(tempFragment, i)\n\t\tproto.appendChild.call(node, tempFragment)\n\t},\n\n\t// prepend(node, ...nodes) {\n\t// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n\t// \t\treturn\n\t// \t}\n\t// \tconst tempFragment = document.createDocumentFragment()\n\t// \tnodes.reverse()\n\t// \tfor (let i of nodes) {\n\t// \t\tproto.appendChild.call(tempFragment, i)\n\t// \t}\n\t// \tif (node.firstChild) {\n\t// \t\tproto.insertBefore.call(node, tempFragment, node.firstChild)\n\t// \t} else {\n\t// \t\tproto.appendChild.call(node, tempFragment)\n\t// \t}\n\t// },\n\n\t// appendTo(node, newNode) {\n\t// \tproto.appendChild.call(newNode, node)\n\t// },\n\n\t// prependTo(node, newNode) {\n\t// \tif (newNode.firstChild) {\n\t// \t\tproto.insertBefore.call(newNode, node, node.firstChild)\n\t// \t} else {\n\t// \t\tproto.appendChild.call(newNode, node)\n\t// \t}\n\t// },\n\n\t// empty(node) {\n\t// \tnode.innerHTML = ''\n\t// },\n\n\tremove(node) {\n\t\tproto.removeChild.call(node.parentNode, node)\n\t},\n\n\t// safeRemove(node) {\n\t// \tproto.appendChild.call(safeZone, node)\n\t// }\n}\n\nexport default DOM\n","import DOM from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport { inform, exec } from '../render-queue.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({state, key, anchor}, ...items) {\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].__EFPLACEHOLDER__, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({state, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({state, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({state, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","import createElement from './element-creator.js'\nimport { queue, inform, exec } from './render-queue.js'\nimport DOM from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\n\nconst bindTextNode = ({node, state, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, state, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\ttextNode.textContent = dataNode[_key]\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({state, children, key, anchor, value}) => {\n\tif (children[key] === value) return\n\tif (value) {\n\t\tif (value.$parent && process.env.NODE_ENV !== 'production') console.warn('[EF]', 'Better detach the component before attaching it to a new component!')\n\t\tif (value.$element.contains(state.$element)) {\n\t\t\tif (process.env.NODE_ENV !== 'production') console.warn('[EF]', 'Cannot mount a component to it\\'s child component!')\n\t\t\treturn\n\t\t}\n\t}\n\n\tinform()\n\t// Update component\n\tif (children[key]) children[key].$umount()\n\t// Update stored value\n\tchildren[key] = value\n\tif (value) value.$mount({target: anchor, parent: state, option: 'before', key})\n\texec()\n}\n\nconst bindMountingNode = ({state, key, children, anchor}) => {\n\tObject.defineProperty(state, key, {\n\t\tget() {\n\t\t\treturn children[key]\n\t\t},\n\t\tset(value) {\n\t\t\tupdateMountingNode({state, children, key, anchor, value})\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n}\n\nconst updateMountingList = ({state, children, key, anchor, value}) => {\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (children[key]) {\n\t\tfor (let j of value) {\n\t\t\tif (j.$element.contains(state.$element)) {\n\t\t\t\tif (process.env.NODE_ENV !== 'production') console.warn('[EF]', 'Cannot mount a component to it\\'s child component!')\n\t\t\t\treturn\n\t\t\t}\n\t\t\tj.$umount()\n\t\t\tDOM.append(fragment, j.$mount({parent: state, key}))\n\t\t}\n\t\tfor (let j of ARR.copy(children[key])) j.$umount()\n\t} else for (let j of value) DOM.append(fragment, j.$mount({parent: state, key}))\n\t// Update stored value\n\tchildren[key].length = 0\n\tARR.push(children[key], ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst bindMountingList = ({state, key, children, anchor}) => {\n\tchildren[key] = defineArr([], {state, key, anchor})\n\tObject.defineProperty(state, key, {\n\t\tget() {\n\t\t\treturn children[key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (children[key] && ARR.equals(children[key], value)) return\n\t\t\tupdateMountingList({state, children, key, anchor, value})\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n}\n\nconst resolveAST = ({node, nodeType, element, state, innerData, refs, children, handlers, subscribers, svg, create}) => {\n\tswitch (nodeType) {\n\t\tcase 'string': {\n\t\t\t// Static text node\n\t\t\tDOM.append(element, document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\tcase 'array': {\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, state, innerData, refs, children, handlers, subscribers, svg, create}))\n\t\t\telse bindTextNode({node, state, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tconst anchor = document.createTextNode('')\n\t\t\tif (node.t === 0) bindMountingNode({state, key: node.n, children, anchor})\n\t\t\telse if (node.t === 1) bindMountingList({state, key: node.n, children, anchor})\n\t\t\telse throw new TypeError(`Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\t// Append anchor\n\t\t\tDOM.append(element, anchor)\n\t\t\t// Display anchor indicator in development mode\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tDOM.before(anchor, document.createComment(`Start of mounting point '${node.n}'`))\n\t\t\t\tDOM.after(anchor, document.createComment(`End of mounting point '${node.n}'`))\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\nconst create = ({node, state, innerData, refs, children, handlers, subscribers, svg, create}) => {\n\tconst [info, ...childNodes] = node\n\tif (!svg && info.t === 'svg') svg = true\n\t// First create an element according to the description\n\tconst element = createElement({info, state, innerData, refs, handlers, subscribers, svg})\n\n\t// Append child nodes\n\tfor (let i of childNodes) resolveAST({node: i, nodeType: typeOf(i), element, state, innerData, refs, children, handlers, subscribers, svg, create})\n\n\treturn element\n}\n\nexport default create\n","import create from './creator.js'\nimport initBinding from './binding.js'\nimport { queueDom, inform, exec } from './render-queue.js'\nimport { resolveReactivePath, resolveSubscriber } from './resolver.js'\nimport DOM from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport { assign } from './utils/polyfills.js'\n\nconst unsubscribe = (_path, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(_path, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\nconst update = function(newState) {\n\tinform()\n\tconst tmpState = assign({}, newState)\n\tif (tmpState.$data) {\n\t\tassign(this.$data, tmpState.$data)\n\t\tdelete(tmpState.$data)\n\t}\n\tif (tmpState.$methods) {\n\t\tassign(this.$methods, tmpState.$methods)\n\t\tdelete(tmpState.$methods)\n\t}\n\tassign(this, tmpState)\n\texec()\n}\n\nconst destroy = function() {\n\tconst {$element, __EFPLACEHOLDER__} = this\n\tinform()\n\tthis.$umount()\n\tfor (let i in this) {\n\t\tthis[i] = null\n\t\tdelete this[i]\n\t}\n\t// Push DOM removement operation to query\n\tqueueDom(() => {\n\t\tDOM.remove($element)\n\t\tDOM.remove(__EFPLACEHOLDER__)\n\t})\n\n\t// Remove all references for memory recycling\n\tdelete this.$element\n\tdelete this.__EFPLACEHOLDER__\n\tdelete this.$parent\n\tdelete this.$key\n\tdelete this.$data\n\tdelete this.$methods\n\tdelete this.$refs\n\tdelete this.$mount\n\tdelete this.$umount\n\tdelete this.$subscribe\n\tdelete this.$unsubscribe\n\t// Render\n\treturn exec()\n}\n\nconst state = class {\n\tconstructor (ast) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: document.createTextNode(''),\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV !== 'production') nodeInfo.placeholder = document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tinform()\n\t\tObject.defineProperties(this, {\n\t\t\t$element: {\n\t\t\t\tget() {\n\t\t\t\t\treturn nodeInfo.element\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t__EFPLACEHOLDER__: {\n\t\t\t\tget() {\n\t\t\t\t\treturn nodeInfo.placeholder\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$parent: {\n\t\t\t\tget() {\n\t\t\t\t\treturn nodeInfo.parent\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$key: {\n\t\t\t\tget() {\n\t\t\t\t\treturn nodeInfo.key\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$methods: {\n\t\t\t\tget() {\n\t\t\t\t\treturn methods\n\t\t\t\t},\n\t\t\t\tset(newMethods) {\n\t\t\t\t\tassign(methods, newMethods)\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$refs: {\n\t\t\t\tvalue: refs,\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$mount: {\n\t\t\t\tvalue: function({target, option, parent, key}) {\n\t\t\t\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\t\t\t\tinform()\n\t\t\t\t\tif (nodeInfo.parent) {\n\t\t\t\t\t\tthis.$umount()\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') console.warn('[EF]', 'Component detached from previous mounting point.')\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!parent) parent = target\n\t\t\t\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\t\t\t\tnodeInfo.parent = parent\n\t\t\t\t\tnodeInfo.key = key\n\t\t\t\t\tqueueDom(mount)\n\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\texec()\n\t\t\t\t\t\treturn nodeInfo.placeholder\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (option) {\n\t\t\t\t\t\tcase 'before': {\n\t\t\t\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'after': {\n\t\t\t\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'replace': {\n\t\t\t\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tDOM.append(target, nodeInfo.placeholder)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn exec()\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$umount: {\n\t\t\t\tvalue: function() {\n\t\t\t\t\tconst {parent, key} = nodeInfo\n\t\t\t\t\tnodeInfo.parent = null\n\t\t\t\t\tnodeInfo.key = null\n\n\t\t\t\t\tinform()\n\t\t\t\t\tif (parent && key !== '__DIRECTMOUNT__' && parent[key]) {\n\t\t\t\t\t\tif (Array.isArray(parent[key])) ARR.remove(parent[key], this)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tparent[key] = null\n\t\t\t\t\t\t\treturn exec()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\t\t\t\tqueueDom(mount)\n\t\t\t\t\treturn exec()\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$subscribe: {\n\t\t\t\tvalue: (pathStr, subscriber) => {\n\t\t\t\t\tconst _path = pathStr.split('.')\n\t\t\t\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], state: this, handlers, subscribers, innerData})\n\t\t\t\t\tinform()\n\t\t\t\t\t// Execute the subscriber function immediately\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\t\t\t\tsubscriberNode.push(subscriber)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error('[EF]', 'Error caught when registering subscriber:\\n', e)\n\t\t\t\t\t}\n\t\t\t\t\texec()\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t$unsubscribe: {\n\t\t\t\tvalue: (_path, fn) => {\n\t\t\t\t\tunsubscribe(_path, fn, subscribers)\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t})\n\t\t// Init root data node\n\t\tresolveReactivePath(['$data'], this, false)\n\n\t\tnodeInfo.element = create({node: ast, state: this, innerData, refs, children, handlers, subscribers, svg: false, create})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n}\n\n// Add $update and $destroy method\nObject.defineProperties(state.prototype, {\n\t$update: {value: update},\n\t$destroy: {value: destroy}\n})\n\nexport default state\n","// Import everything\nimport state from './lib/renderer.js'\nimport { onNextRender, inform, exec, bundle, isPaused } from './lib/render-queue.js'\nimport { version } from '../package.json'\n\nconst create = (value) => {\n\tconst ast = value\n\tconst ef = class extends state {\n\t\tconstructor(newState) {\n\t\t\tinform()\n\t\t\tsuper(ast)\n\t\t\tif (newState) this.$update(newState)\n\t\t\texec()\n\t\t}\n\t}\n\treturn ef\n}\n\nexport { create, onNextRender, inform, exec, bundle, isPaused, version }\n\nif (process.env.NODE_ENV !== 'production') console.info('[EF]', `ef-core v${version} initialized!`)\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {create as createComponent, onNextRender, inform, exec, bundle} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n// Change parser\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\nconst t = (...args) => create(mixStr(...args))\n\nexport { create, onNextRender, inform, exec, bundle, setParser, parseEft, t, version }\n\nif (process.env.NODE_ENV !== 'production') console.info('[EF]', `ef.js v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n"],"names":["const","oct","RegExp","ucp","uni","hex","esc","b","t","n","v","f","r","O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","escaped","split","char","let","escapedStr","replace","push","join","checkEscape","splitWith","escapedSplit","i","splitBy","splitArr","shift","reserved","mustache","spaceIndent","hashref","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","tmpl","mustaches","match","pushStr","textArr","str","dotToSpace","parseNodeProps","splited","name","value","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","ref","parsingInfo","indentReg","spaces","getIndent","offset","offsetReg","getOffset","depth","content","test","getDepth","removed","prevDepth","removeOffset","prevType","topExists","type","currentNode","ast","resolveDepth","minDepth","info","tagInfo","tag","class","parseTag","newNode","parseEvent","l","listener","ops","k","getEventOptions","escapedName","splitEvents","m","method","_value","ref$6","result","exprs","parseText","parseEft","template","TypeError","tplType","lines","typeOf","Array","isArray","mixStr","getVal","proto","prototype","ARR","copy","arr","call","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","window","Set","from","unique","modificationQueue","domQueue","userQueue","count","queue","handlers","queueDom","handler","inform","execUserQueue","exec","immediate","execModifications","execDomModifications","setTimeout","assign","Object","ee","er","resolveReactivePath","enume","node","defineProperty","get","set","data","configurable","enumerable","subscriberCallStack","execSubscribers","subscriberNode","pushStack","subscriber","error","popStack","isnan","initBinding","bind","_key","parentNode","subscribers","innerData","handlerNode","dataNode","resolveAllPath","hasOwnProperty","resolve","state","$data","initDataNode","getEvent","props","bubbles","cancelable","event","document","createEvent","initEvent","getElement","ref$1","element","svg","createElementNS","createElement","createByTag","refs","regTmpl","_handler","updateOthers","addAttr","attr","setAttribute","key","removeAttribute","getAttrHandler","addProp","prop","expr","_update","addEventListener","dispatchEvent","tagName","radios","querySelectorAll","selected","checked","addValListener","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","$methods","Node","DOM","before","tempFragment","createDocumentFragment","nodes","appendChild","insertBefore","after","nextSibling","append","nodeType","removeChild","DOMARR","$destroy","this","poped","$umount","elements","$mount","parent","anchor","__EFPLACEHOLDER__","tempArr","shifted","sorted","spliced","bindMountingNode","children","$parent","$element","contains","target","updateMountingNode","bindMountingList","defineProperties","fragment","updateMountingList","resolveAST","createTextNode","create","textNode","textContent","bindTextNode","childNodes","unsubscribe","resolveSubscriber","methods","nodeInfo","placeholder","safeZone","mount","$key","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","$update","newState","tmpState","parser","valType","eftParser","super","createComponent","cb","newParser"],"mappings":"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"}